# Spiegazione Dettagliata del Codice mini\_serv

## Introduzione

Questo progetto, chiamato `mini_serv`, è una simulazione minimale di un server TCP scritto in C.
 Utilizza la funzione `select()` per gestire più connessioni contemporaneamente in modalità non concorrente,
 ovvero senza usare `fork()`, `pthread`, o processi multipli.
  È un esercizio perfetto per comprendere i fondamenti della programmazione di rete, la gestione dei file descriptor e i socket in ambiente UNIX.

### Perché questo esercizio è importante?

* **Approccio minimalista**: Impari a scrivere un server TCP partendo da zero, senza dipendenze o astrazioni complesse.
* **Comprensione profonda**: Ogni riga di codice ha un impatto diretto sul funzionamento del programma.
* **Concetti chiave della programmazione di rete**: Socket, file descriptor, `select()`, gestione della memoria e comunicazione tra processi.

## Obiettivo del Codice

Implementare un server che:

* Accetti connessioni TCP da client sulla porta specificata.
* Gestisca più client contemporaneamente usando `select()`.
* Trasmetta messaggi ricevuti da un client a tutti gli altri (broadcast).
* Notifichi l'arrivo e la disconnessione dei client.

Questo tipo di architettura è chiamata **server echo broadcast**, un pattern base da cui derivano le chat server e molte applicazioni multiplayer.

## Header e Librerie

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/select.h>
#include <netinet/in.h>
```

### Spiegazione:

* `stdlib.h`, `stdio.h`, `string.h`: librerie standard per gestione memoria, I/O e stringhe.
* `unistd.h`: funzioni POSIX come `read`, `write`, `close`.
* `sys/socket.h`: creazione e manipolazione dei socket.
* `netinet/in.h`: strutture e funzioni per indirizzi IP e porte.
* `sys/select.h`: permette il multiplexing I/O, ossia monitorare più file descriptor contemporaneamente.

> **Approfondimento**: I socket sono punti di comunicazione bidirezionali tra processi. `select()` permette di sapere quali socket sono "pronti" a leggere/scrivere, evitando il blocco del processo principale.

## Strutture e Variabili Globali

```c
typedef struct s_client {
    int id;
} t_client;

t_client *clients[FD_SETSIZE];
int max_fd = 0, next_id = 0;
```

### Spiegazione:

* Ogni client connesso ha un ID univoco assegnato tramite `next_id`.
* `clients` è un array dove ogni indice rappresenta un file descriptor.
* `max_fd` è necessario per `select()`, che deve sapere il valore massimo tra tutti i descrittori monitorati.

> **Nota storica**: `FD_SETSIZE` è limitato, storicamente a 1024. Oggi si usano alternative più scalabili come `epoll` su Linux o `kqueue` su BSD/macOS.

## Gestione Errori

```c
void fatal(int sockfd) {
    write(2, "Fatal error\n", strlen("Fatal error\n"));
    if (sockfd != -1) close(sockfd);
    for (int i = 0; i <= max_fd; ++i) {
        if (clients[i]) {
            close(i);
            free(clients[i]);
            clients[i] = NULL;
        }
    }
    exit(1);
}
```

### Spiegazione:

* La funzione gestisce gli errori critici: libera risorse e chiude il server in modo ordinato.
* `write(2, ...)` scrive su `stderr`, che ha file descriptor 2.

> **Suggerimento**: È buona pratica gestire le risorse in caso di errore per evitare memory leak o socket aperti.

## Broadcast

```c
void broadcast(int sender_fd, char *msg) {
    for (int i = 0; i <= max_fd; ++i) {
        if (clients[i] && i != sender_fd) {
            if (send(i, msg, strlen(msg), 0) < 0) {
                close(i);
                free(clients[i]);
                clients[i] = NULL;
            }
        }
    }
}
```

### Spiegazione:

* La funzione manda un messaggio a tutti i client connessi eccetto al mittente.
* Se `send()` fallisce, si presume che il client si sia disconnesso.

> **Curiosità**: Il broadcast è usato in molte applicazioni reali, ad esempio nei giochi multiplayer per aggiornare tutti i client.

## Funzione `main()`

### Parsing Argomenti

```c
if (argc != 2) {
    write(2, "Wrong number of arguments\n", ...);
    exit(1);
}
port = atoi(argv[1]);
```

Controlla che l’utente abbia fornito la porta come argomento.

### Creazione Socket

```c
sockfd = socket(AF_INET, SOCK_STREAM, 0);
```

* `AF_INET`: uso di IPv4.
* `SOCK_STREAM`: connessione orientata (TCP).

### Binding

```c
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl(2130706433);  // 127.0.0.1
servaddr.sin_port = htons(port);
```

* `htons`/`htonl`: convertono numeri da host byte order a network byte order.

> **Approfondimento**: NBO è lo standard big-endian usato nelle comunicazioni di rete.

### Listen e inizializzazione

```c
if (listen(sockfd, 10) < 0) fatal(sockfd);
FD_ZERO(&active);
FD_SET(sockfd, &active);
max_fd = sockfd;
```

* `FD_ZERO` azzera tutti i bit del set.
* `FD_SET` aggiunge un descrittore al set.

## Ciclo Principale e `select()`

```c
while (1) {
    read_fds = active;
    if (select(max_fd + 1, &read_fds, NULL, NULL, NULL) < 0)
        continue;
    ...
}
```

### Spiegazione:

* `select()` blocca il processo fino a quando uno dei file descriptor è pronto.
* `read_fds` viene modificato da `select()`, quindi bisogna copiarlo ogni volta.

## Nuove Connessioni

```c
if (fd == sockfd) {
    connfd = accept(sockfd, ...);
    clients[connfd] = calloc(1, sizeof(t_client));
    clients[connfd]->id = next_id++;
    FD_SET(connfd, &active);
    if (connfd > max_fd) max_fd = connfd;
    broadcast(...);
}
```

* `accept()` accetta una nuova connessione e restituisce un nuovo descrittore.
* Viene assegnato un ID univoco al nuovo client.

## Ricezione Messaggi

```c
r = recv(fd, buf, sizeof(buf) - 1, 0);
if (r <= 0) {
    broadcast disconnessione
    close, free, FD_CLR
} else {
    parsing riga per riga
    broadcast messaggio
}
```

* `recv()` legge i dati in arrivo.
* Se `r <= 0`, il client ha chiuso la connessione.
* I messaggi vengono analizzati riga per riga, separati da `\n`.

## Concetti Teorici da Approfondire

### Socket Programming

* I socket sono l'interfaccia standard per comunicazione in rete.
* TCP (Stream) garantisce consegna ordinata e affidabile dei dati.
* `bind`, `listen`, `accept`, `recv`, `send`, `close` sono le chiamate fondamentali.

### Multiplexing con `select()`

* Utile quando non si vogliono creare thread/processi multipli.
* Limite di scalabilità, ma eccellente per imparare.

### Gestione della Memoria

* `calloc` inizializza la memoria a zero, utile per strutture.
* Sempre liberare memoria con `free`.

### File Descriptor

* Ogni socket è un file descriptor.
* `FD_SET`, `FD_CLR`, `FD_ISSET`, `FD_ZERO` permettono la manipolazione dei set.

## Suggerimenti Pratici

* Prova a scrivere un client in Python per testare il server:

```python
import socket
s = socket.socket()
s.connect(('127.0.0.1', PORTA))
s.send(b"Hello!\n")
```

* Testa il comportamento con più client simultanei (usa più terminali o `telnet`).
* Aggiungi un comando `/quit` per permettere al client di uscire ordinatamente.

## Conclusione

Questo esercizio è molto formativo: ti mette a contatto diretto con il cuore della comunicazione di rete. Ti insegna a pensare in termini di eventi (arrivo messaggi, nuove connessioni) e a strutturare un'applicazione server in modo ordinato e robusto.

> "Chi padroneggia `select()` comprende davvero il funzionamento del networking di basso livello."

> Continua a esplorare: una volta capito `select`, studia `poll()`, `epoll()`, e le architetture reattive!

Buono studio e buon lavoro!
